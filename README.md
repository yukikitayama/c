# C

CPU
- Central processing unit
- Does most of the computing work
- Instructions are executed here

RAM
- Random access memory
- Stores the data of a program while it's running
  - Instructions of its program
  - Data used while computer is executing the program
- Think as an ordered sequence of boxes
  - When a box is full, 1. When a box is empty, 0.
  - Each box represens **one binary digit**; 0 or 1
  - Each box is called **bit**

Bits in memory
- Grouped into sets of eight
- A set of eight bits is **byte**
- Each byte is labeled with a number. This label is **address**.
- Address of a byte is unique and the address refers a particular byte in memory

**Memory consists of a large number of bits that are in groups of eight (called bytes) and each byte has a unique address**.

Variable
- The name that you give to a computer about a memory location which is used to store a value.

Hard drive
- Permanent storage
- Stores files that contain program source code, even while the computer is turned off.

Operating system
- A program that controls the entire operation of a computer
- All input and output
- Manages the computer's resources and handles the execution of programs.

Fetch / Execute cycle
- Life of a CPU
- Fetches an instruction from memory (using **registers**) and executes it (loop)

Higher level programming languages
- Easy to write programs
- Opposite of assembly language
- C is a higher level programming language

Compiler
- A program that translates the high-level language source code into the detailed set of machine language instructions the computer requires
- Generates the tedious instructions to the CPU
- Checks valid syntax of programs, finds errors, and reports them to you
- Doesn't produce an executable until you fix them.

C
- Popular for programming embedded system of microprocessors found in autombiles, cameras, DVD players, etc.
- Strong role in Linux. All major operating systems are written in C and/or C++.
- C program is a valid C++ program
- Provides low-level access to memory
- Evolved from a previous programming language named B
- **Traditional C**
- Standard version of C was created (C89/C90, C99, C11)
- A program written only in **Standard C** and without any hardware-dependent assumptions will run correctly on any platform with a standard C compiler.
- Most C code written today is based on C89
- C99 has not been widely adopted and not all popular C compilers support it.
- C11 is the current standard.

Steps of creating C program
- Editing
- Compiling
  - Converts source code into machine language and detects and reports errors in code
  - 1st stage of compilation is **preprocessing phase** where code may be modified or added to
  - 2nd stage of compilation is actual compilation to generate **object code**. Object code is the output from the compiler and stored in files called **object files** (`.obj` (Windows ), `.o` (Linux) extension)
  - `cc -c` or `gcc -c`. If you omit -c flag, program will automatically be linked
- Linking
  - Gets the program into a final form for execution on the computer
  - Usually occurs automatically when compiling
  - Combines the object modules generated by the compiler with additional libraries needed by the program to create the whole executable.
  - Produces an executable file. `.exe` in Windows, `.out` in UNIX / Linux.
  - Many IDEs have a build option, which will compile and link program in a single operation to produce the executable.
- Executing

C compiler
- **Cygwin**

CodeLite
- `<workspace-name>/build-Debug/bin/` has the executables from build.
- `<workspace-name>/<project-name>/` contains object files.
- https://stackoverflow.com/questions/49366039/debugging-c-program-with-two-arguments-passed

Compiler error
- Usually check the compiler errors at the top and first fix it.

Compiler warnings
- Do not igore them.
- e.g., `warning: '<variable-name>' is used uninitialized...`.

Linker errors
- Having trouble linking all the **object files** together to create an **executable**.
- Usually there is a library or object file that is missing.

Runtime errors
- Errors that occur when the program is executing.
- e.g., Divide by zero, file not found, out of memory.

Structure of C program
- `main()` is the entry point to the program. It's the special function. At least on and only one `main()`.
- Case sensitive.
- Indentation doesn't matter for compilation. It's for readability.
- All the statements end with `;`.

Comment
- `/* */` is a multi-line comment
- `//` is a single line comment. Things before `//` won't be ignored

Preprocessor
- Unique feature of C that isn't found in many other higher-level programming languages.
- An instruction to compiler to do something before compiling the source code.
- Preprocessor statements start with `#`.
- Preprocessor statements must be the first non-space character on the line.
- `#define` creates constants and macros.
- `#include` build library
- Conditionals like `ifdef`.

`#include`
- Preprocessor directive
- Not part of the executable program, but the program won't work without it.
- The compiler is instructed to include the contents of the `.h` header file in your program.

Header file
- Defines information about some of the functions that are provided by a header file
- Specify information that the compiler uses to integrate any predefined functions within a program
- Header file name is case sensitive.
- You should always write header file name in lowercase.
- `#include <xxx.h>` means to look for a file in one or more **standard system directories**
- `#include "xxx.h"` means to first look in the **current directory**, typically for **user defined header files**.
- `#ifndef` (if not defined) and `#define` is for efficiency to protect against multiple inclusions of a header file.
- Header file includes
  - `#define` directives
  - Structure declarations
  - `typedef` statements
  - Function prototypes
- Executable code normally goes into a source code file, not a header file.
  - Header file only tells you, this function exists, this constant exists. But implementation goes to `xxx.c` file.
- e.g., `stdio.h` is standard input/output library.

`printf()`
- A standard library function
- Outputs information to the command line (**standard output stream**)
- Output destination is command line by default.

`scanf()`
- Ask user to enter data into a program via terminal/console
- By default, reads the input from the **standard input stream (stdin)** and scans that input according to the format provided.
- stdin is text characters, but `scanf()` converts the string character-by-character to a desired data type.
- **Control string** indicates the destination data type for the input stream of characters
- Uses **pointers** to variables.
- Returns the number of items to read
- First argument is format, and second argument is variable
  - If reads a string into a character array, don't use `&`
  - If reads a string into the other data types, use `&`
- Uses **whitespaces** to decide how to divide the input into separater fields.
- `scanf()` is inverse of `printf()`.

Common C mistakes
- Misplacing a **semicolon**
- Confusing the operator `=` with the operator `==`
- Omitting prototype declarations
  - Always safest to include a prototype declaration for all functions that you call
  - Either explicitly yourself or implicitly by including the correct header file in your program.
- Failing to include the header file that includes the definition for a C-programming library function being used in the program
- Confusing a character constant and a character string.
  - `text = 'a';` a single character is assigned to text
    - `text` is normally declared to be a `char` variable
  - `text = "a";` a pointer to the character string "a" is assigned to text
    - `text` should be declared to be of type **pointer** to `char`.
- Using the wrong bounds for an array
  - Valid subscripts of an array range from 0 through the number of elements minus one
  - Forgetting to reserve an extra location in an array for the terminating null character of a string
- Confusing the operator `->` with the operator `.` when referencing structure members
  - `.` is used for structure variables
  - `->` is used for structure pointer variables
- Omitting the anpersand before nonpointer variables in a `scanf()` call
  - All arguments appearing after the format string in a `scanf()` call must be pointers
- Using a pointer variable before it's initialized
  - You can only apply the indirection operator to a pointer variable after you have set the variable pointing somewhere
`char_pointer` is never set pointing to anything, so the assignment is not meaningful.
```
char *char_pointer;
*char_pointer = 'X';
```
- Omitting the break statement at the end of a case in a switch statement
- Inserting a semicolon at the end of a preprocessor definition
- Omitting a closing parenthesis or closing quotation marks on any statement. 

Common compiler error
- `-Wall` is an option for the compiler to notify all cases where there are implicit decisions
- Warnings
  - Special situations in which an anomaly has been detected
  - The final executable program may be obtained with any number of warning
  - But you should remove all warnings. Do not consider the program correct until all warnings have been eliminated.
- 'variable' undeclared (first use in this function)
- Warning: implicit declaration of function
  - Need to declare a function prototype
- Warning: control reaches end of non-void function
  - When a function has been defined as returning a result but no return statement has been included.
- Warning: unused variable
  - Should remove it
- Undefined reference to
  - Appear in linking phase, when there is a function invoked in the code that has not been defined anywhere
  - Make sure its definition is compiled
- Error: conflicting types for
  - Two definitions of a function prototype have been found
  - Prototype and definition doesn't match

Advanced topic
- `typedef`
- `void*`
- static libraries
- shared objects
- macros
- unions
- function pointer
- variable arguments to function
- dynami linking (dlm_open)
- signals
- forking
- inter-process communication
- threading
- concurrency
- sockets
- setjmp and longjmp
- memory management and fragmentation
- portable program
- kernel modules (drivers, ioctls)
- linker flags
- profiling, tracing (gprof, dtrace, strace)
- valgrind (race condition, memory leak)